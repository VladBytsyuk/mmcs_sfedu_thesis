% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Здесь нужно написать введение.

% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\section{Знакомство}
	\subsection{Erlang}
		Erlang - функциональный язык программирования, созданный для разработки
		распределенных динамических систем. Основные его приемущества: быстрая и 
		эффективная разработка, устойчивость системы к аппаратным сбоям и 
		возможность обновления всей системы без остановки программ.

		\subsubsection{Переменные и атомы} 
			Переменные в Erlang объявляются следующим образом:
			\begin{lstlisting}
X = 42.
			\end{lstlisting}
			Все переменные начинаются с заглавной буквы. В Erlang переменным 
			можно присваивать значения только один раз. Переменная которой 
			значение уже присвоено называется связанной. В противном случае 
			она называется свободной. Попытка присвоить связанной переменной 
			новое значение приведет к сообщению об ошибке.

			Атомы используются для представления нечисловых констант. 
			\begin{lstlisting}
monday.
			\end{lstlisting}
			Все атомы начинаются с прописной буквы. Также атомы могут быть 
			заключены в одиночные кавычки ('). 
			\begin{lstlisting}
'January'.
			\end{lstlisting}
			В таком случае атом может начинаться с большой буквы.
			Значением атома является сам атом.  
	

		\subsubsection{Сопоставление по образцу}
			В Erlang символ = означает операцию сопоставления по
			образцу.
			\begin{lstlisting}
2 + 4 = 3 + 3.
			\end{lstlisting}
			В процессе выполнения данного участка кода сначала вычислится 
			3 + 3, далее вычислится 2 + 4, а потом сопоставятся 2 результата.
			\begin{lstlisting}
Y = 6 * 7.
			\end{lstlisting}
			В процессе выполнения данного участка кода сначала вычислится
			6 * 7, а потом так как переменная Y свободная, то ее значение станет 
			равно значению правой стороны выражения, и равенство станет верным.
			

		\subsubsection{Кортежи}
			Кортеж - единая группа из фиксированного числа объектов. Группа является 
			анонимной, как и каждое отдельное поле кортежа.
			\begin{lstlisting}
{1, september, 2012}.
{point, 6, 7}.
			\end{lstlisting}
			Часто первым элементом кортежа используют атом, котрый описывает этот кортеж.
		
			Кортежи могут быть вложенными друг в друга.
			\begin{lstlisting}
{date,
    {day, 1},
    {month, september},
    {year, 2012}
}.
			\end{lstlisting}

			Возможно присваивать переменным значения отдельных элементов кортежа.
			\begin{lstlisting}
{Day, Month, Year} = {1, september, 2012}.
			\end{lstlisting}
			В переменную Day запишется значение 1, в Month - september, а в Year - 2012.
			
			\begin{lstlisting}
{Name, _} = {joe, armstrong}.
			\end{lstlisting}
			Символ \_ называется анонимной переменной. Такой переменной не привыязывается 
			соответствующее значение. Результатом выполнения данного участка кода это привязка
			переменной Name значения joe.


		\subsubsection{Списки} 
			Списки используются для хранения различых данных.
			\begin{lstlisting}
[{joe, armstrong}, {1, september, 2012}, 42].
			\end{lstlisting}
			Головой списка называется его первый элемент. Если удалить голову из списка,
			то останется хвост исходного списка. 
			\begin{lstlisting}
[H|T] = [{joe, armstrong}, {1, september, 2012}, 42].
			\end{lstlisting}
			В результате к переменной H будет привязано значение
			\begin{lstlisting} 
{joe, armstrong}
			\end{lstlisting}
			а переменной T значение 
			\begin{lstlisting}
[{1, september, 2012}, 42].
			\end{lstlisting}
			
			Следующим образом можно добавлять элементы в список:
			\begin{lstlisting}
[{82, 56}, morning|T].
			\end{lstlisting}
			Результатом будет список
			\begin{lstlisting} 
[{82, 56}, morning, {1, september, 2012}, 42].
			\end{lstlisting}
		
			Конкатенация списков производится следующим образом:
			\begin{lstlisting}
[34, red] ++ [{point, 6, 7}].
			\end{lstlisting}
			Результатом будет список 
			\begin{lstlisting}
[34, red, {point, 6, 7}].
			\end{lstlisting}
	

		\subsubsection{Функции}
			Рассмотрим описание функций в Erlang на примере нахождения площади прямоугольника и круга.
			\begin{lstlisting}
area({rectangle, Width, Height}) -> Width * Height;
area({circle, Radius}) -> 3.14159 * Radius * Radius.
			\end{lstlisting}
			Функция area содержит 2 варианта сопоставления аргументов - клаузы. 
			Первый вариант необходима для находения площади прямоугольника, а
			второй - круга. 
			Результатом вызова 
			\begin{lstlisting}
area({rectangle, 2, 3}).
			\end{lstlisting}
			будет число 6. Выберется первый вариант выполнения функции, так как первым элементом 
			кортежа является rectangle.
			
	

	\subsection{Красно-черные деревья}
		Красно-черное дерево - двоичное дерево поиска, узлы которого 
		разделены на красные (red) и черные (black). Для таких деревьев
		должны выполняться красно-черные свойства (RB properties), 
		гарантирующие, что глубины любых двух листьев отличаются не более
		чем в 2 раза.

		Узлы красно-черного дерева обычно содержат следующие поля:
		\begin{enumerate}
			\item Значение
			\item Цвет
			\item Родитель
			\item Левый ребенок
			\item Правый ребенок
		\end{enumerate}	

		Важно отметить, что если ребенок или родитель отсутствует, то
		соответсвующее поле содержит черный лист.
		
		Рассмотрим упомянутые выше красно-черные свойства (RB properties):
		\begin{enumerate}
			\item Каждый узел дерева - либо красный, либо черный.
			\item Корень дерева - черный.
			\item Каждый лист - черный.
			\item Если узел красный, то оба его ребенка черные.
			\item Все простые пути, идущие от корня к листьям, содержат 
				  одинаковое количество черных узлов.
		\end{enumerate}
		
		Для удобства работы, все листья заменяются одним черным листом.
		Это обычный узел дерева со значением nil, черным цветом и произвольными данными
		о потомках. Использование подобного узла позволяет рассматривать дочерний 
		по отношению к узлу черный лист как обычный узел с известным предком.
		
		\underline{Черная высота узла X} - количество черных узлов на любом простом 
		пути от узла X (не считая сам узел) к листу. Обозначим черную высоту,
		как bh(X).

		В соответсвии со свойством 5 - черная высота узла - точно определяемое значение,
		поскольку все нисходящие простые пути из узла содержат олно и то же 
		количество черных узлов.
	
		\underline{Черная высота дерева} - черная высота его корня.

		\underline{Лемма}

		Красно-черное дерево с $n$ внутренними узлами имеет высоту, не превышающую 
		$2\lg(n+1)$.
	
		Операции поиска, минимума, макисмума, предков, потомков, вставки, удаления выполняется 
		за время $O(\lg h)$, где $h$ - высота красно-черного дерева.

		Так как операции вставки и удаления изменяют красно-черное дерево,
		то в результате их работы могут нарушаться красно-черные свойства. 
		Для восстановления красно-черных свойств необходимо изменить:
		\begin{enumerate}
			\item Цвета некоторых узлов дерева.
			\item Родительски-дочерние связи некоторых узлов дерева.
		\end{enumerate}
		
		Последнее выполняется с помощью поворотов. Это локальные операции в
		дереве поиска, сохраняющие красно-черные свойства.
		Существует 2 типа поворотов: левый и правый.
		
		\begin{figure}[H]
			\centering
			%Здесь могла быть ваша лягушка.
			\includegraphics[width=\textwidth]{img/tan-aus.png}
			\caption{\label{fig:tan-aus}Пример левого и правого поворотов.}
		\end{figure}

		\underline{Замечание}

		При выполнении левого поворота в узле X предполагается, что
		его правый ребенок Y не является черным узлом.
	
		При выполнении правого поворота в узле Y предполагается, что
		его левый ребенок X не является черным узлом.

		Рассмотрим алгоритм вставки в красно-черное дерево. Вставка выполняется в 2 этапа:
		\begin{enumerate}
			\item Вставка нового узла в красно-черное дерево, как в обычное бинарное
				  дерево поиска, и окрашивает его в красный цвет.
			\item Выполнение необходимых поворотов и перекрашиваний узлов 
				  красно-черного дерева.
		\end{enumerate}

		При этом возникает следующая проблема - нарушаются красно-черные свойства.
		При выполнении необходимых поворотов и перекрашиваний узлов красно-черного 
		дерева корень дерева может быть окрашен в красный цвет, что будет протворечить
		свойству 2, а при вставки нового узла в красно-черное дерево, и окрашивании
		его в красный цвет может возникнуть ситуация, когда у красного узла будет 
		красный ребенок.

		При вставке возможны 4 случая нарушения четвертого красно-черного свойства:
		\begin{figure}[H]
			\centering
			\includegraphics[width=\textwidth]{img/tan-aus.png}
			\caption{Пример возможных нарушений красно-черных свойств после вставки.}
		\end{figure}  


\section{Реализации}
	\subsection{Структура дерева}
		Упорядоченное множество реализовано с помощью красно-черного дерева. 
		Упорядоченность и уникальность элементов обеспечивается тем, 
		что красно-черное дерево является двоичным деревом поиска.

		Дерево реализовано как кортеж, хранящий в себе свои поддеревья.
		\begin{lstlisting}
{Key, Color, Left, Right}
		\end{lstlisting}
		где Key - значение, Color - цвет узла, Left - левое поддерево,
		Right - правое поддерево.

		Лист дерева представляется в виде 
		\begin{lstlisting}
{nil, black, nil, nil}
		\end{lstlisting}
		т.к. у листа нет ни значения, ни потомков, а его цвет всегда черный


	\subsection{Вставка и удаление}
		\subsubsection{Вставка}
			Рассмотри алгоритм вставки. Для соблюдения красно-черных свойств необходимо:
			\begin{enumerate}
				\item Вставить новый узел в красно-черное дерево, как в обычное бинарное 
					  дерево поиска, и окрасить его в красный цвет.
				\item Произвести балансировку всего дерева, от корня к листьям.
				\item Окрасить корень в черный цвет, т.к. в процессе балансировки он мог 
				      стать красным.
			\end{enumerate}

			\begin{lstlisting}
add_element(Key, Tree) ->
    make_black(ins(Key, Tree)).
			\end{lstlisting}
			где
			\begin{lstlisting}
make_black({Key, _, Left, Right}) ->
    {Key, black, Left, Right}.
			\end{lstlisting}
			окрашивает узел в черный цвет вне зависимости от того, какого цвета он был раньше.
	
			\begin{lstlisting}
ins(Key, Tree)
			\end{lstlisting}
			вставляет в дерево Tree значение Key, и производит его балансировку.
		
			\begin{lstlisting}
ins(Key, {nil, black, nil, nil}) ->
    {Key, red, {nil, black, nil, nil}, {nil, black, nil, nil}};
			\end{lstlisting} 
			если функция вызвана для пустого дерева, то создать дерево с корнем, у которого 
			значение Key красного цвета.
		
			\begin{lstlisting}
ins(Key, {Key, Color, Left, Right}) ->
    {Key, Color, Left, Right};
			\end{lstlisting}
			если функция вызвана для дерева, в котором существует значение Key, то 
			прекратить рекурсивные вызовы, а дерево оставить без изменений.
			
			\begin{lstlisting}
ins(Key, {Key1, Color, Left, Right}) when Key < Key1 ->
    balance({Key1, Color, ins(Key, Left), Right});
			\end{lstlisting}
			если значение необходимо вставить в левое поддерево, то вызвать функцию для 
			левого поддерева и сбалансировать текущее дерево. Аналогично и для правого 
			поддерева:
			\begin{lstlisting}
ins(Key, {Key1, Color, Left, Right}) when Key > Key1 ->
    balance({Key1, Color, Left, ins(Key, Right)}).
			\end{lstlisting}
			
			Функция balance выполняющая балансировку дерева реализует 4 случая нарушения 
			четвертого красно-черного свойства рассмотренные ранее.
			
			Случай 1.
			\begin{lstlisting}
balance({Key1, 
         black, 
         Left1, 
         {Key2, red, Left2, {Key3, red, Left3, Right3}}}) ->    
    {Key2, 
     red, 
     {Key1, black, Left1, Left2}, 
     {Key3, black, Left3, Right3}};		    
			\end{lstlisting}
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Случай 1}
			\end{figure}
			
			Случай 2.
			\begin{lstlisting}
balance({Key1, 
         black, 
         Left1, 
         {Key2, red, {Key3, red, Left3, Right3}, 
         Right2}}) ->   
    {Key3, 
     red, 
     {Key1, black, Left1, Left3}, 
     {Key2, black, Right3, Right2}};	    
			\end{lstlisting} 
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Случай 2}
			\end{figure}
			
			Случай 3.
			\begin{lstlisting}
balance({Key1, 
         black, 
         {Key2, red, {Key3, red, Left3, Right3}, Right2}, 
         Right1}) ->  
    {Key2, 
     red, 
     {Key3, black, Left3, Right3}, 
     {Key1, black, Right2, Right1}};	    
			\end{lstlisting}
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Случай 3}
			\end{figure}
			
			Случай 4.
			\begin{lstlisting}
balance({Key1, 
         black, 
         {Key2, red, Left2, {Key3, red, Left3, Right3}}, 
         Right1}) ->   
    {Key3, 
     red, 
     {Key2, black, Left2, Left3}, 
     {Key1, black, Right3, Right1}};	    
			\end{lstlisting}
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Случай 4}
			\end{figure}
			
			Случай 5. Красно-черные свойства не нарушены.
			\begin{lstlisting}
balance(Tree) -> 
    Tree.	
			\end{lstlisting}
			
		\subsubsection{Удаление}
			Реализация использует арифметику цветов. К красному и черному цветам
			можно добавить или отнять черный цвет. Пусть при вычитании из красного цвета 
			черного цвета получится негативный черный, вычитание из черного цвета черного 
			даст красный цвет, добавление к красному цвету черного даст черный и добавление к
			черному цвету черного даст двойной черный цвет.
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Арифметика цветов}
			\end{figure}
			Реализуется арифметика цветов следующей функцией добавления цвета:
			\begin{lstlisting}
addBlack({Key, red, Left, Right}) ->
    {Key, black, Left, Right};
	
addBlack({Key, black, Left, Right}) ->
    {Key, doubleBlack, Left, Right}.			
			\end{lstlisting}
			Функция вычитания цвета не используется.
			
			Рассмотри алгоритм удаления. Для соблюдения красно-черных свойств необходимо:
			\begin{enumerate}
				\item Если у удаляемого узла 1 потомок и этот узел красный, то удаляем его, 
					  а на его место ставим единственного потомка.
					  Если у удаляемого узла 1 потомок и этот узел черный, то удаляем его,
					  а на его место ставим единственного потомка с увеличенным цветом.
					  Если у удаляемого узла 2 потомка, то удаляем его, а на его место 
					  ставим узел из левого поддерева с максимальным значением, удаляя 
					  из левого поддерева этот узел. 
				\item Произвести балансировку всего дерева, от корня к листьям, исправляя 
					  цвета узлов.
				\item Окрасить корень и листья в черный цвет, т.к. в процессе удаления 
					  и балансировки они могли изменить цвет. 
			\end{enumerate}
			
			\begin{lstlisting}
del_element(Key, Tree) -> 
    nilFix(make_black(del(Key, Tree))).
			\end{lstlisting}
			где 
			\begin{lstlisting}
nilFix({nil, doubleBlack, nil, nil}) ->
    {nil, black, nil, nil};
	
nilFix(Tree) ->
    Tree.					
			\end{lstlisting}	
			если агрументом является двойной черный лист преобразует его в черный,
			а если аргумент - дерево, то возвращает его без изменений.
			
			Рассмотрим функцию del, которая удаляет узел с заданным значением из дерева,
			а затем вызывает функцию балансировки дерева delFix. 
			\begin{lstlisting}
del(_, {nil, black, nil, nil}) ->
    {nil, black, nil, nil};
			\end{lstlisting}
			если производится попытка удалить узел из пустого дерева, то вернуть пустое дерево.
			\begin{lstlisting}
del(Key, {Key, red, Left, {nil, black, nil, nil}}) ->
    Left;
	
del(Key, {Key, red, {nil, black, nil, nil}, Right}) ->
    Right;
			\end{lstlisting}
			если цвет удаляемого узла красный, и у него есть только один потомок, то
			вернуть потомка.
			\begin{lstlisting}
del(Key, {Key, black, Left, {nil, black, nil, nil}}) ->
    addBlack(Left);
		
del(Key, {Key, black, {nil, black, nil, nil}, Right}) ->
    addBlack(Right);
			\end{lstlisting}
			если цвет удаляемого узла черный, и у него есть только один потомок, то
			вернуть потомка с добавленным цветом для сохранения 5 красно-черного свойства.
			\begin{lstlisting}
del(Key, {Key, Color, Left, Right})	->
    delFix({max(Left), Color, del(max(Left), Left), Right});
			\end{lstlisting}
			если у удаляемого узла 2 потомка, то вернуть дерево в котором вместо удаленного 
			узла будет узел с максимальным значением из его левого потомка, цвет удаленного узла, 
			левый потомок без своего максимального значения, а правый потомок останется без изменений.
			Результат необходимо сбалансировать.
			\begin{lstlisting}
del(Key, {KeyTree, ColorTree, LeftTree, RightTree}) 
    when Key < KeyTree ->
    delFix({KeyTree, ColorTree, del(Key, LeftTree), RightTree});
			
del(Key, {KeyTree, ColorTree, LeftTree, RightTree}) 
    when Key > KeyTree ->	
    delFix({KeyTree, ColorTree, LeftTree, del(Key, RightTree)}).
			\end{lstlisting}
			рекурсивный поиск удаляемого узла в дереве и балансировка дерева после 
			удаления.
			
			Функция delFix реализует следующие варианты нарушения красно-черных свойств 
			при удаалении узла:
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 1}
			\end{figure}
			\begin{lstlisting}
delFix({Key2, 														   				
        Color2, 													   				
        {Key1, doubleBlack, Left1, Right1}, 						   				
        {Key3, black, {Left3Key, black, 
                       Left3Left, Left3Right}, 	   				
                      {Right3Key, black, 
                       Right3Left, Right3Right}})
->																	   				
    addBlack({Key2, 												   				
              Color2, 												   				
              nilFix({Key1, black, Left1, Right1}), 				   				
              {Key3, red, {Left3Key, black, 
                           Left3Left, Left3Right},  				
                          {Right3Key, black, 
                           Right3Left, Right3Right}}});				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 2}
			\end{figure}
			\begin{lstlisting}
delFix({Key2, 														   				
        Color2, 													   				
        {Key1, black, {Left1Key,  black, 
                       Left1Left,  Left1Right}, 	   				
                      {Right1Key, black, 
                       Right1Left, Right1Right}},    				
        {Key3, doubleBlack, Left3, Right3}}) 															   				
->																	   				
    addBlack({Key2, 												   				
              Color2, 											   				
              {Key1, red, {Left1Key,  black, 
                           Left1Left,  Left1Right},  				
                          {Right1Key, black, 
                           Right1Left, Right1Right}},				
              nilFix({Key3, black, Left3, Right3})					   				
             });													   				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 3}
			\end{figure}
			\begin{lstlisting}
delFix({Key2, 														   											
        black, 														   				
        {Key1, doubleBlack, Left1, Right1}, 						   				
        {Key3, red, {Left3Key,  black, 
                     Left3Left,  Left3Right}, 	   				
                    {Right3Key, black, 
                     Right3Left, Right3Right}}})															   				
->																	   				
    {Key3, 															   				
     black, 														   				
     delFix({Key2, red, 
             {Key1, doubleBlack, Left1, Right1},    				
             {Left3Key, black, Left3Left, Left3Right}}),			 
     {Right3Key, black, Right3Left, Right3Right}};																				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 4}
			\end{figure}
			\begin{lstlisting}
delFix({Key2,																		
        black,																		
        {Key1, red, {Left1Key,  black, 
                     Left1Left,  Left1Right},						
                    {Right1Key, black, 
                     Right1Left, Right1Right}},					
        {Key3, doubleBlack, Left3, Right3}})																			
->																					
    {Key1,																			
     black,																										
     {Left1Key,  black, Left1Left,  Left1Right},									
     delFix({Key2, red, {Right1Key, black, 
                         Right1Left, Right1Right},			
 					    {Key3, doubleBlack, 
 					     Left3, Right3}})};																				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 5}
			\end{figure}
			\begin{lstlisting}
delFix({Key2,																		
        Color2,																		
        {Key1, doubleBlack, Left1, Right1},											
        {Key4, black, {Key3, red, 
                       Left3, Right3}, 									
                      {Right4Key, black, 
                       Right4Left, Right4Right}}})																			
->																					
    delFix({Key2,																	
            Color2,																	
            {Key1, doubleBlack, Left1, Right1},										
            {Key3, black, 
             Left3, {Key4, red, 
                     Right3, {Right4Key, black, 
                              Right4Left, Right4Right}}});																				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 6}
			\end{figure}
			\begin{lstlisting}
delFix({Key3,																		
        Color3,																		
        {Key1, black, {Left1Key, black, 
                       Left1Left, Left1Right}, 					
                      {Key2, red, 
                       Left2, Right2}},					
        {Key4, doubleBlack, Left4, Right4}})																			
->																					
    delFix({Key3, 																	
            Color3,																	
            {Key2, black, 
             {Key1, red, 
              {Left1Key, black, Left1Left, Left1Right}, 
              Left2}, 
             Right2},													
            {Key4, doubleBlack, Left4, Right4}});																				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 7}
			\end{figure}
			\begin{lstlisting}
delFix({Key2,																		
        Color2,																		
        {Key1, doubleBlack, Left1, Right1},											
        {Key3, black, 
         Left3,	{Key4, red, 
                 Left4, {Right4Key, black, 
                 		 Right4Left, Right4Right}}}})																			
->																					
    {Key3,																			
     Color2,																		
     {Key2, black, nilFix({Key1, black, Left1, Right1}), Left3},															
	 {Key4, black, 
	  Left4, {Right4Key, black, Right4Left, Right4Right}}};																				
			\end{lstlisting}
			
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучай 8}
			\end{figure}
			\begin{lstlisting}
delFix({Key3,																		
        Color3,																		
        {Key2, black, 
         {Key1, red, 
          {Left1Key, black, 
          Left1Left, Left1Right}, 
          Right1}, 													
		 Right2},														
		{Key4, doubleBlack, Left4, Right4}})																			
->																					
    {Key2,																			
     Color3,																		
     {Key1, black, 
      {Left1Key, black, 
       Left1Left, Left1Right}, 
      Right1},															
	 {Key3, black, 
	  Right2, 
	  nilFix({Key4, black, Left4, Right4})}};																				
			\end{lstlisting}
			
			
	\subsection{Логические функции}
		Для работы с упорядоченным множеством реализованы следующие логические операции:
		\begin{enumerate}
			\item Проверка на принадлежность элемента упорядоченному множеству
			\item Проверка на то, является ли одно упорядоченное множество
				  подмножеством другого
			\item Проверка на непересекаемость двух упорядоченных множеств
		\end{enumerate} 
		Рассмотрим каждую из них.
		
		\subsubsection{Принадлежность элемента множеству}
			Проверка на принадлежность элемента упорядоченному множеству
			реализуется с помощью функции is\_element(Elem, OSet), где Elem - 
			значение элемента, а OSet - упорядоченное множество.
			\begin{lstlisting}
is_element(_,  {nil, black, nil, nil}) ->
    false;				
			\end{lstlisting}
			Пустому множеству не может принадлежать никакой элемент.
			\begin{lstlisting}
is_element(Elem, {Elem, _, _, _}) ->
    true;
			\end{lstlisting}
			Если найден узел с искомым значением, то элемент принадлежит множеству.
			\begin{lstlisting}
is_element(Elem, {CurrElem, _, Left, Right}) ->		
    if
        Elem < CurrElem -> 
            is_element(Elem, Left);
        Elem > CurrElem -> 
            is_element(Elem, Right)
    end.	
			\end{lstlisting}
			Поиск элемента в дереве реализующем упорядоченное множество.
			
		\subsubsection{Является ли одно упорядоченное множество подмножеством другого}
			Проверка на то, является ли одно упорядоченное множество подмножеством другого
			реализуется с помощью функции is\_subset(OSetA, OSetB), где OSetA - предполагаемое
			подмножество OSetB.
			\begin{lstlisting}
is_subset({nil, black, nil, nil}, _) ->
    true;	
			\end{lstlisting}
			Пустое множество является подмножеством любого множества.	
			\begin{lstlisting}
is_subset({Key, _, Left, Right}, OSetB) ->
    IsElem = is_element(Key, OSetB),
    if
        IsElem -> 
            is_subset(Left, OSetB) 
            and 
            is_subset(Right, OSetB);
        true -> 
            false
    end.
			\end{lstlisting}
			Проверяется принадлежность корня OSetA множеству OSetB, и если корень
			принадлежит OSetB, то проверяется принадлежность левого и правого поддерева
			множеству OSetB. Иначе OSetA не является подмножеством OSetB.
			
		\subsubsection{Непересекаемость двух упорядоченных множеств}
			Проверка на непересекаемость двух упорядоченных множеств реализуется с помощью функции
			is\_disjoint(OSetA, OSetB), где OSetA и OSetB - упорядоченные множества.
			\begin{lstlisting}
is_disjoint(_, {nil, black, nil, nil}) ->
    true;	
			\end{lstlisting}
			Никакое множество не пересекается с пустым.
			\begin{lstlisting}
is_disjoint(OSetA, {Key, _, Left, Right}) ->
    IsElem = is_element(Key, OSetA),
    if
        IsElem -> 
            false;
        true -> 
            is_disjoint(OSetA, Left) 
            and 
            is_disjoint(OSetA, Right)
	end.
			\end{lstlisting}
			Проверяется принадлежность корня OSetB множеству OSetA, и если корень
			принадлежит OSetA, то множества не являются пересекающимися. Иначе
			проверяется непересекаемость левого и правого поддерева множеству OSetA.
		
		
	\subsection{Перевод в список и обратно, свертка и фильтрация}
		\subsubsection{Перевод упорядоченного множества в список}
			\begin{lstlisting}
to_list({nil, black, nil, nil}) ->
    [];
			\end{lstlisting}
			Пустое множество переводится в пустой список.
			\begin{lstlisting}
to_list({Key, _, Left, Right}) ->
    to_list(Left) ++ [Key] ++ to_list(Right).
			\end{lstlisting}
			Для сохранения упорядоченности в список переводится левое поддерево, потом 
			добавляется корневое значение, а затем в список переводится правое поддерево.
			
		\subsubsection{Перевод списка в упорядоченное множество}
			\begin{lstlisting}
from_list(List) ->
    lists:foldl(fun(Elem, OSet) -> 
                    add_element(Elem, OSet) 
                end, 
                new(), 
                List).
			\end{lstlisting}			
			Перевод списка в упорядоченное множество реализуется с помощью стандартной 
			функции свертки списка и функции добавления элемета в множество. К каждому 
			элементу списка List, применяется функция fun(Elem, OSet) где Elem - элемент
			List, а в качестве OSet изначально берется пустое множество.
			
		\subsubsection{Свертка}
			Свертка fold(Fun, Acc, OSet) применяет к каждому элементу упорядоченного
			множества OSet функцию Fun(Elem, Acc) и возвращает итоговое значение Acc.
			\begin{lstlisting}
fold(_, Acc, {nil, black, nil, nil}) ->
    Acc;	
			\end{lstlisting}
			Если свертка применяется к пустому множеству, то просто возвращается Acc.
			\begin{lstlisting}
fold(Fun, Acc, {Key, _, Left, Right}) ->
    Fun(Fun(Key, fold(Fun, Acc, Left)), fold(Fun, Acc, Right)).
			\end{lstlisting}
			Если же свертка применяется к не пустому множеству, то Fun применяется к левому, 
			а затем и к правому поддереву.
		
		\subsubsection{Фильтрация}
			Фильтрация filter(Pred, OSet) применяет к каждому элементу OSet предикат Pred, и 
			возвращает упорядоченное множество элементов из OSet удовлетворяющих Pred.
			\begin{lstlisting}
filter(Pred, OSet) ->
    OSetList = to_list(OSet),
    FilteredList = lists:filter(Pred, OSetList),
    from_list(FilteredList).	
			\end{lstlisting}
			Упорядоченное множество переводится в список, список фильтруется с помощью стандартной 
			функции, а затем результат переводится из списка обратно в упорядоченное множество.
			
			
	\subsection{Объединение, пересечение, разность}
		Реализации операций объединения, пересечения и разности отличаются друг от друга, для 
		достижения лучшей скорости.
		
		\subsubsection{Объединение}
			Операция объединения реализована рекурсивно. 
			\begin{lstlisting}			
union(OSetA, {nil, black, nil, nil}) ->
    OSetA;
			\end{lstlisting}
			Объединением упорядоченного множества OSetA с пустым, будет упорядоченное множество OSetA.
			\begin{lstlisting}
union(OSetA, {Key, _, Left, Right}) ->
    union(union(add_element(Key, OSetA), Left), Right).
			\end{lstlisting}
			Для объединения упорядоченных множеств OSetA и OSetB, во множество OSetA добавляется корневой 
			элемент OSetB, а после применяется операция объединения OSetA к левому и правому поддереву OSetB.  
		
			Для объединения более чем двух упорядоченных множеств используется функция объединения от списка
			упорядоченных множеств.
			\begin{lstlisting}
union([OSet1, OSet2 | []]) ->
    union(OSet1, OSet2);
			\end{lstlisting}
			Если в списке всего два упорядоченных множества, то использовать операцию объединения от двух 
			упорядоченных множеств.
			\begin{lstlisting}
union([OSet1, OSet2 | OSetsListTail]) ->
    OSetUnion = union(OSet1, OSet2),
    union([OSetUnion | OSetsListTail]).
			\end{lstlisting}
			В противном случае, заменить в исходном списке два первых упорядоченных множества
			их объединением и найти объединение нового списка.
				
		\subsubsection{Пересечение}
			Операция пересечения реализована перебором одного из упорядоченных множеств.
			\begin{lstlisting}
intersection(OSetA, OSetB) ->
    intersection(OSetA, OSetB, {nil, black, nil, nil}).
			\end{lstlisting}
			При первом вызове операции пересечения для упорядоченных множеств OSetA и OSetB
			вызывается функция пересечения с пустым аккумулятором.
			\begin{lstlisting}	
intersection({nil, black, nil, nil}, _, Acc) ->
    Acc;
			\end{lstlisting}
			При пересечении любого упорядоченного множества с пустым множеством необходимо вернуть аккумулятор.
			\begin{lstlisting}	
intersection(OSetA, OSetB, Acc) ->
    OSetALeft = min(OSetA),
    OSetANew = del_element(OSetALeft, OSetA),
    IsElem = is_element(OSetALeft, OSetB),
    if 
        IsElem =:= true -> 
            AccNew = add_element(OSetALeft, Acc),
            intersection(OSetANew, OSetB, AccNew);
        IsElem =:= false -> 
            intersection(OSetANew, OSetB, Acc)
    end.
			\end{lstlisting}
			В противном случае удаляем из упорядоченного множества OSetA минимальный элемент, и если он 
			принадлежит еще и множеству OSetB, то добавляем его в аккумулятор, иначе находим пересечение 
			нового упорядоченного множества OSetA и неизмененного OSetB.
			
			Функция пересечения более чем двух упорядоченных множеств реализуется аналогично с объединением:
			\begin{lstlisting}
intersection([OSet1, OSet2 | []]) ->
    intersection(OSet1, OSet2);

intersection([OSet1, OSet2 | OSetsListTail]) ->
    OSetIntersection = intersection(OSet1, OSet2),
    intersection([OSetIntersection | OSetsListTail]).
			\end{lstlisting}
			
		\subsubsection{Разность}
			Операция разности двух упорядоченных множеств, как и операция пересечения, реализована 
			перебором одного из упорядоченных множеств.
			\begin{lstlisting}
subtract(OSetA, {nil, black, nil, nil}) ->
    OSetA;
			\end{lstlisting}
			Вычитание из упорядоченного множества OSetA пустого множества даст упорядоченное множество OSetA.
			\begin{lstlisting}
subtract(OSetA, OSetB) ->
    OSetBLeft = min(OSetB),
    OSetBNew = del_element(OSetBLeft, OSetB),
    IsElem = is_element(OSetBLeft, OSetA),
    if 
        IsElem =:= true -> 
            OSetANew = del_element(OSetBLeft, OSetA),
            subtract(OSetANew, OSetBNew);
        IsElem =:= false -> 
            subtract(OSetA, OSetBNew)
    end.	 	
			\end{lstlisting}
			Если же из упорядоченного множества OSetA вычитаем непустое упорядоченное множество OSetB,
			то удаляем из упорядоченного множества OSetB минимальный элемент, и если он 
			принадлежит еще и множеству OSetA, то удаляем его из множества OSetA и вычитаем из нового
			упорядоченного множества OSetA новое упорядоченное множество OSetB, иначе вычитаем из неизмененного
			упорядоченного множества OSetA новое упорядоченное множество OSetB.
			
			
			
			
\section{Сравнение с модулями sets и ordsets}
	\subsection{Вставка и удаление}
	\subsection{Логические функции}
	\subsection{Перевод в список и обратно, свертка и фильтрация}
	\subsection{Объединение, пересечение, разность}

\section{Несколько примеров в~\LaTeX{}}
\label{sec:examples}

Некоторые часто используемые
команды приведены в качестве примера ниже (и варианты — в
комментариях). Мы рекомендуем внимательно прочесть данный
текст и изучить его исходный код прежде, чем начинать писать
свой собственный. Кроме того, можно дать и такой совет: идущий
ниже текст не убирать до самого конца, а просто оставлять его
позади своего собственного текста, чтобы в любой момент можно
было проконсультироваться с данными примерами.

\subsection{Как вставлять листинги и рисунки}

Для крупных листингов есть два способа. Первый красивый, но в нём не допускается
кириллица (у вас может встречаться в комментариях и
печатаемых сообщениях), он представлен на листинге~\ref{list:hwbeauty}.
\begin{ListingEnv}[H]% буква H означает Here, ставим здесь,
% элементы, которые нежелательно разрывать обычно не ставят
% посреди страницы: вместо H используется t (top, сверху страницы),
% или b (bottom) или p (page, на отдельной странице)
\begin{lstlisting}
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello, world" << endl;
    system("pause");
    return 0;
}
\end{lstlisting}
%следующую команду для генерации подписи можно опустить,
% хотя рекомендуется все специальные элементы (таблицы, рисунки,
% листинги) подписывать. Если подпись пропустить, листинг также не получит
% номера и на него не сошлёшься в будущем
\caption{Программа “Hello, world” на \protect\cpp}
% далее метка для ссылки:
\label{list:hwbeauty}
\end{ListingEnv}

Второй не такой красивый, но без ограничений (см.~листинг~\ref{list:hwplain}).
\begin{ListingEnv}[H]
\begin{Verb}

#include <iostream>
using namespace std;

int main()
{
    cout << "Привет, мир" << endl;
}
\end{Verb}
\caption{Программа “Hello, world” без подсветки}
\label{list:hwplain}
\end{ListingEnv}

Можно использовать первый для вставки небольших фрагментов
внутри текста, а второй для вставки полного
кода в приложении, если таковое имеется.

Если нужно вставить совсем короткий пример кода (одна или две строки), то выделение  линейками и нумерация может смотреться чересчур громоздко. В таких случаях можно использовать окружения \texttt{lstlisting} или \texttt{Verb} без \texttt{ListingEnv}. Приведём такой пример с указанием языка программирования, отличного от заданного по умолчанию:
\begin{lstlisting}[language=Haskell]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{lstlisting}
Такое решение~--- со вставкой нумерованных листингов покрупнее
и вставок без выделения для маленьких фрагментов~--- выбрано,
например, в книге Эндрю Таненбаума и Тодда Остина по архитектуре
компьютера~\autocite{TanAus2013} (см.~рис.~\ref{fig:tan-aus}).

Наконец, для оформления идентификаторов внутри строк
(функция \lstinline{main} и тому подобное) используется
\texttt{lstinline} или, самое простое, моноширинный текст
(\texttt{\textbackslash texttt}).

\begin{figure}[p]% p означает, что нужно выделить для рисунка
% отдельную страницу; применяется для больших рисунков
\centering
%Здесь могла быть ваша лягушка.
\includegraphics[width=\textwidth]{img/tan-aus.png}
\caption{\label{fig:tan-aus}Пример оформления листингов в~\autocite{TanAus2013}}
\end{figure}

Использовать внешние файлы (например, рисунки) можно и на \href{http://overleaf.com}{overleaf.com}: ищите кнопочку upload.

\subsection{Как оформить таблицу}

Для таблиц обычно используются окружения table и tabular --- см. таблицу~\ref{tab:widgets}. Внутри окружения tabular используются специальные команды пакета booktabs — они очень красивые; самое главное: использование вертикальных линеек считается моветоном.

\begin{table}
\centering
\caption{\label{tab:widgets}Подпись к таблице --- сверху}
\begin{tabular}{llr}
\toprule
\multicolumn{2}{c}{Item} \\
\cmidrule(r){1-2}
Животное  & Описание    & Цена (\$) \\
\midrule
Gnat      & per gram    & 13.65      \\
          & each        & 0.01       \\
Gnu       & stuffed     & 92.50      \\
Emu       & stuffed     & 33.33      \\
Armadillo & frozen      & 8.99       \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Как набирать формулы}

\LaTeX{} is great at typesetting mathematics. Let $X_1, X_2, \ldots, X_n$ be a sequence of independent and identically distributed random variables with $\text{E}[X_i] = \mu$ and $\text{Var}[X_i] = \sigma^2 < \infty$, and let
$$S_n = \frac{X_1 + X_2 + \cdots + X_n}{n}
      = \frac{1}{n}\sum_{i}^{n} X_i$$
denote their mean. Then as $n$ approaches infinity, the random variables $\sqrt{n}(S_n - \mu)$ converge in distribution to a normal $\mathcal{N}(0, \sigma^2)$.

\subsection{Как оформлять списки}

Нумерованные списки (окружение enumerate, команды item)…

\begin{enumerate}
  \item Like this,
  \item and like this.
\end{enumerate}

\dots маркированные списки \dots

\begin{itemize}
  \item Like this,
  \item and like this.
\end{itemize}

\dots списки-описания \dots

\begin{description}
  \item[Word] Definition
  \item[Concept] Explanation
  \item[Idea] Text
\end{description}

\Conc

Помните, что на все пункты списка литературы должны быть ссылки. \LaTeX\ просто не добавит информацию об издании из bib"/файла, если на это издание нет ссылки в тексте. Часто студенты используют в работе  электронные ресурсы: в этом нет ничего зазорного при одном условии: при каждом заимствовании следует ставить соответствующую ссылку. В качестве примера приведём ссылку на сайт нашего института~\autocite{mmcs}.

Для дальнейшего изучения \LaTeX\ рекомендуем книгу Львовского~\autocite{Lvo2003}: она хорошо написана, хотя и несколько устарела.
Обычно стоит искать подсказки на
\href{http://tex.stackexchange.com/}{tex.stackexchange.com}, а также
читать документацию по установленным пакетам с помощью
команды
\begin{Verb}
texdoc имя_пакета
\end{Verb}
или на \href{http://ctan.org/}{ctan.org}.

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
