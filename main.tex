% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro
	В данной работе было проведено сравнение времени выполнения стандартных реализаций множества и упорядоченного множества 
	и реализованного упорядоченного множества на языке программирования Erlang. 

	Сравнение проводится для всех функций рассматриваемых структур данных. Реализация функций подобрана исходя из
	скорости выполнения. Упорядоченное множество реализовано на основе красно-черного дерева. 
	
	Целью работы является сравнение времени выполнения функций различных структур данных и 
	анализ зависимости этого времени от реализации структуры. 

\Task
	\begin{enumerate}
		\item Реализовать структуру данных упорядоченное множество на языке программирования Erlang.
		\item Сравнить время выполнения основных операций реализованной структуры данных с реализациями из модулей
			  ordsets и sets. 
	\end{enumerate}

\section{Обзор используемых технологий и алгоритмов}
	\subsection{Erlang}
		Erlang - функциональный язык программирования, созданный для разработки	распределенных динамических систем.~\cite{erl} 
		Основные его приемущества: быстрая и эффективная разработка, устойчивость системы к аппаратным сбоям и 
		возможность обновления всей системы без остановки программ.

		\subsubsection{Переменные и атомы} 
			Переменные в Erlang начинаются с заглавной буквы. Им можно присваивать значения только один раз. 
			Переменная которой значение уже присвоено называется связанной. В противном случае она называется свободной. 
			Попытка присвоить связанной переменной новое значение приведет к сообщению об ошибке.
			\begin{lstlisting}
X = 42.
			\end{lstlisting}

			Атомы используются для представления нечисловых констант. Значением атома является сам атом.
			\begin{lstlisting}
monday.
			\end{lstlisting}  

		\subsubsection{Кортежи}
			Кортеж - единая группа из фиксированного числа объектов. Группа является анонимной, как и каждое отдельное 
			поле кортежа. Часто первым элементом кортежа используют атом, котрый описывает этот кортеж.
			\begin{lstlisting}
{1, september, 2012}.
{point, 6, 7}.
			\end{lstlisting}
			
			Возможно присваивать переменным значения отдельных элементов кортежа. Символ \_ называется анонимной переменной. 
			Такой переменной не привыязывается соответствующее значение.
			\begin{lstlisting}
{Name, _} = {joe, armstrong}.
			\end{lstlisting} 

		\subsubsection{Списки} 
			Списки используются для хранения различых данных. Головой списка называется его первый элемент. Если удалить 
			голову из списка, то останется хвост исходного списка.
			\begin{lstlisting}
[{joe, armstrong}, {1, september, 2012}, 42].
			\end{lstlisting}

		\subsubsection{Функции}
			Рассмотрим описание функций в Erlang на примере нахождения площади прямоугольника и круга.
			\begin{lstlisting}
area({rectangle, Width, Height}) -> Width * Height;
area({circle, Radius}) -> 3.14159 * Radius * Radius.
			\end{lstlisting}
			Функция area содержит 2 варианта сопоставления аргументов - клаузы. Первый вариант необходим для находения 
			площади прямоугольника, а второй - круга. 			
	

	\subsection{Красно-черные деревья}
		Красно-черное дерево - двоичное дерево поиска, узлы которого 
		разделены на красные (red) и черные (black). Для таких деревьев
		должны выполняться красно-черные свойства (RB properties), 
		гарантирующие, что глубины любых двух листьев отличаются не более
		чем в 2 раза.~\cite{kormen}

		Узлы красно-черного дерева обычно содержат следующие поля:
		\begin{enumerate}
			\item Значение
			\item Цвет
			\item Родитель
			\item Левый ребенок
			\item Правый ребенок
		\end{enumerate}	

		Важно отметить, что если ребенок или родитель отсутствует, то
		соответсвующее поле содержит черный лист.
		
		Рассмотрим упомянутые выше красно-черные свойства (RB properties):
		\begin{enumerate}
			\item Каждый узел дерева - либо красный, либо черный.
			\item Корень дерева - черный.
			\item Каждый лист - черный.
			\item Если узел красный, то оба его ребенка черные.
			\item Все простые пути, идущие от корня к листьям, содержат 
				  одинаковое количество черных узлов.
		\end{enumerate}
		
		Для удобства работы, все листья заменяются одним черным листом.
		Это обычный узел дерева со значением nil, черным цветом и произвольными данными
		о потомках. Использование подобного узла позволяет рассматривать дочерний 
		по отношению к узлу черный лист как обычный узел с известным предком.
		
		\underline{Черная высота узла X} - количество черных узлов на любом простом 
		пути от узла X (не считая сам узел) к листу. Обозначим черную высоту,
		как bh(X).

		В соответсвии со свойством 5 - черная высота узла - точно определяемое значение,
		поскольку все нисходящие простые пути из узла содержат олно и то же 
		количество черных узлов.
	
		\underline{Черная высота дерева} - черная высота его корня.

		\underline{Лемма}

		Красно-черное дерево с $n$ внутренними узлами имеет высоту, не превышающую 
		$2\lg(n+1)$.
	
		Операции поиска, минимума, макисмума, предков, потомков, вставки, удаления выполняется 
		за время $O(\lg h)$, где $h$ - высота красно-черного дерева.

		Так как операции вставки и удаления изменяют красно-черное дерево,
		то в результате их работы могут нарушаться красно-черные свойства. 
		Для восстановления красно-черных свойств необходимо изменить:
		\begin{enumerate}
			\item Цвета некоторых узлов дерева.
			\item Родительски-дочерние связи некоторых узлов дерева.
		\end{enumerate}
		
		Последнее выполняется с помощью поворотов. Это локальные операции в
		дереве поиска, сохраняющие красно-черные свойства.
		Существует 2 типа поворотов: левый и правый.
		
		\begin{figure}[H]
			\centering
			%Здесь могла быть ваша лягушка.
			\includegraphics[width=\textwidth]{img/tan-aus.png}
			\caption{\label{fig:tan-aus}Пример левого и правого поворотов.}
		\end{figure}

		\underline{Замечание}

		При выполнении левого поворота в узле X предполагается, что
		его правый ребенок Y не является черным узлом.
	
		При выполнении правого поворота в узле Y предполагается, что
		его левый ребенок X не является черным узлом.


\section{Реализации}
	\subsection{Структура дерева}
		Упорядоченное множество реализовано с помощью красно-черного дерева. 
		Упорядоченность и уникальность элементов обеспечивается тем, 
		что красно-черное дерево является двоичным деревом поиска.

		Дерево реализовано как кортеж, хранящий в себе свои поддеревья.
		\begin{lstlisting}
{Key, Color, Left, Right}
		\end{lstlisting}
		где Key - значение, Color - цвет узла, Left - левое поддерево,
		Right - правое поддерево.

		Лист дерева представляется в виде 
		\begin{lstlisting}
{nil, black, nil, nil}
		\end{lstlisting}
		т.к. у листа нет ни значения, ни потомков, а его цвет всегда черный


	\subsection{Вставка и удаление}
		\subsubsection{Вставка}
			Рассмотри алгоритм вставки. Для соблюдения красно-черных свойств необходимо:
			\begin{enumerate}
				\item Вставить новый узел в красно-черное дерево, как в обычное бинарное 
					  дерево поиска, и окрасить его в красный цвет.
				\item Произвести балансировку всего дерева, от корня к листьям.
				\item Окрасить корень в черный цвет, т.к. в процессе балансировки он мог 
				      стать красным.
			\end{enumerate}

			\begin{lstlisting}
add_element(Key, Tree) ->
    make_black(ins(Key, Tree)).
			\end{lstlisting}
			где
			\begin{lstlisting}
make_black({Key, _, Left, Right}) ->
    {Key, black, Left, Right}.
			\end{lstlisting}
			окрашивает узел в черный цвет вне зависимости от того, какого цвета он был раньше.
	
			\begin{lstlisting}
ins(Key, Tree)
			\end{lstlisting}
			вставляет в дерево Tree значение Key, и производит его балансировку.
		
			\begin{lstlisting}
ins(Key, {nil, black, nil, nil}) ->
    {Key, red, {nil, black, nil, nil}, {nil, black, nil, nil}};
			\end{lstlisting} 
			если функция вызвана для пустого дерева, то создать дерево с корнем, у которого 
			значение Key красного цвета.
		
			\begin{lstlisting}
ins(Key, {Key, Color, Left, Right}) ->
    {Key, Color, Left, Right};
			\end{lstlisting}
			если функция вызвана для дерева, в котором существует значение Key, то 
			прекратить рекурсивные вызовы, а дерево оставить без изменений.
			
			\begin{lstlisting}
ins(Key, {Key1, Color, Left, Right}) when Key < Key1 ->
    balance({Key1, Color, ins(Key, Left), Right});
			\end{lstlisting}
			если значение необходимо вставить в левое поддерево, то вызвать функцию для 
			левого поддерева и сбалансировать текущее дерево. Аналогично и для правого 
			поддерева:
			\begin{lstlisting}
ins(Key, {Key1, Color, Left, Right}) when Key > Key1 ->
    balance({Key1, Color, Left, ins(Key, Right)}).
			\end{lstlisting}
			
			Функция balance выполняющая балансировку дерева реализует 4 случая нарушения 
			четвертого красно-черного свойства рассмотренные ранее.
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/insert/clause_4.png}
				\caption{Случаи нарушения красно-черных свойств при вставке}
			\end{figure}
			
		
		\subsubsection{Удаление}
			Реализация использует арифметику цветов. К красному и черному цветам
			можно добавить или отнять черный цвет. Пусть при вычитании из красного цвета 
			черного цвета получится негативный черный, вычитание из черного цвета черного 
			даст красный цвет, добавление к красному цвету черного даст черный и добавление к
			черному цвету черного даст двойной черный цвет.~\cite{RBdelete}
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Арифметика цветов}
			\end{figure}
			Реализуется арифметика цветов следующей функцией добавления цвета:
			\begin{lstlisting}
addBlack({Key, red, Left, Right}) ->
    {Key, black, Left, Right};
	
addBlack({Key, black, Left, Right}) ->
    {Key, doubleBlack, Left, Right}.			
			\end{lstlisting}
			Функция вычитания цвета не используется.
			
			Рассмотри алгоритм удаления. Для соблюдения красно-черных свойств необходимо:
			\begin{enumerate}
				\item Если у удаляемого узла 1 потомок и этот узел красный, то удаляем его, 
					  а на его место ставим единственного потомка.
					  Если у удаляемого узла 1 потомок и этот узел черный, то удаляем его,
					  а на его место ставим единственного потомка с увеличенным цветом.
					  Если у удаляемого узла 2 потомка, то удаляем его, а на его место 
					  ставим узел из левого поддерева с максимальным значением, удаляя 
					  из левого поддерева этот узел. 
				\item Произвести балансировку всего дерева, от корня к листьям, исправляя 
					  цвета узлов.
				\item Окрасить корень и листья в черный цвет, т.к. в процессе удаления 
					  и балансировки они могли изменить цвет. 
			\end{enumerate}
			
			\begin{lstlisting}
del_element(Key, Tree) -> 
    nilFix(make_black(del(Key, Tree))).
			\end{lstlisting}
			где 
			\begin{lstlisting}
nilFix({nil, doubleBlack, nil, nil}) ->
    {nil, black, nil, nil};
	
nilFix(Tree) ->
    Tree.					
			\end{lstlisting}	
			если агрументом является двойной черный лист преобразует его в черный,
			а если аргумент - дерево, то возвращает его без изменений.
			
			Рассмотрим функцию del, которая удаляет узел с заданным значением из дерева,
			а затем вызывает функцию балансировки дерева delFix. 
			\begin{lstlisting}
del(_, {nil, black, nil, nil}) ->
    {nil, black, nil, nil};
			\end{lstlisting}
			если производится попытка удалить узел из пустого дерева, то вернуть пустое дерево.
			\begin{lstlisting}
del(Key, {Key, red, Left, {nil, black, nil, nil}}) ->
    Left;
	
del(Key, {Key, red, {nil, black, nil, nil}, Right}) ->
    Right;
			\end{lstlisting}
			если цвет удаляемого узла красный, и у него есть только один потомок, то
			вернуть потомка.
			\begin{lstlisting}
del(Key, {Key, black, Left, {nil, black, nil, nil}}) ->
    addBlack(Left);
		
del(Key, {Key, black, {nil, black, nil, nil}, Right}) ->
    addBlack(Right);
			\end{lstlisting}
			если цвет удаляемого узла черный, и у него есть только один потомок, то
			вернуть потомка с добавленным цветом для сохранения 5 красно-черного свойства.
			\begin{lstlisting}
del(Key, {Key, Color, Left, Right})	->
    delFix({max(Left), Color, del(max(Left), Left), Right});
			\end{lstlisting}
			если у удаляемого узла 2 потомка, то вернуть дерево в котором вместо удаленного 
			узла будет узел с максимальным значением из его левого потомка, цвет удаленного узла, 
			левый потомок без своего максимального значения, а правый потомок останется без изменений.
			Результат необходимо сбалансировать.
			\begin{lstlisting}
del(Key, {KeyTree, ColorTree, LeftTree, RightTree}) 
    when Key < KeyTree ->
    delFix({KeyTree, ColorTree, del(Key, LeftTree), RightTree});
			
del(Key, {KeyTree, ColorTree, LeftTree, RightTree}) 
    when Key > KeyTree ->	
    delFix({KeyTree, ColorTree, LeftTree, del(Key, RightTree)}).
			\end{lstlisting}
			рекурсивный поиск удаляемого узла в дереве и балансировка дерева после 
			удаления.
			
			Функция delFix реализует следующие варианты нарушения красно-черных свойств 
			при удаалении узла:
			\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/tan-aus.png}
				\caption{Cлучаи нарушения красно-черных свойств при удалении}
			\end{figure}
			
			
	\subsection{Логические функции}
		Для работы с упорядоченным множеством реализованы следующие логические операции:
		\begin{enumerate}
			\item Проверка на принадлежность элемента упорядоченному множеству
			\item Проверка на то, является ли одно упорядоченное множество
				  подмножеством другого
			\item Проверка на непересекаемость двух упорядоченных множеств
		\end{enumerate} 
		Рассмотрим каждую из них.
		
		\subsubsection{Принадлежность элемента множеству}
			Проверка на принадлежность элемента упорядоченному множеству
			реализуется с помощью функции is\_element(Elem, OSet), где Elem - 
			значение элемента, а OSet - упорядоченное множество.
			\begin{lstlisting}
is_element(_,  {nil, black, nil, nil}) ->
    false;				
			\end{lstlisting}
			Пустому множеству не может принадлежать никакой элемент.
			\begin{lstlisting}
is_element(Elem, {Elem, _, _, _}) ->
    true;
			\end{lstlisting}
			Если найден узел с искомым значением, то элемент принадлежит множеству.
			\begin{lstlisting}
is_element(Elem, {CurrElem, _, Left, Right}) ->		
    if
        Elem < CurrElem -> 
            is_element(Elem, Left);
        Elem > CurrElem -> 
            is_element(Elem, Right)
    end.	
			\end{lstlisting}
			Поиск элемента в дереве реализующем упорядоченное множество.
			
		\subsubsection{Является ли одно упорядоченное множество подмножеством другого}
			Проверка на то, является ли одно упорядоченное множество подмножеством другого
			реализуется с помощью функции is\_subset(OSetA, OSetB), где OSetA - предполагаемое
			подмножество OSetB.
			\begin{lstlisting}
is_subset({nil, black, nil, nil}, _) ->
    true;	
			\end{lstlisting}
			Пустое множество является подмножеством любого множества.	
			\begin{lstlisting}
is_subset({Key, _, Left, Right}, OSetB) ->
    IsElem = is_element(Key, OSetB),
    if
        IsElem -> 
            is_subset(Left, OSetB) 
            and 
            is_subset(Right, OSetB);
        true -> 
            false
    end.
			\end{lstlisting}
			Проверяется принадлежность корня OSetA множеству OSetB, и если корень
			принадлежит OSetB, то проверяется принадлежность левого и правого поддерева
			множеству OSetB. Иначе OSetA не является подмножеством OSetB.
			
		\subsubsection{Непересекаемость двух упорядоченных множеств}
			Проверка на непересекаемость двух упорядоченных множеств реализуется с помощью функции
			is\_disjoint(OSetA, OSetB), где OSetA и OSetB - упорядоченные множества.
			\begin{lstlisting}
is_disjoint(_, {nil, black, nil, nil}) ->
    true;	
			\end{lstlisting}
			Никакое множество не пересекается с пустым.
			\begin{lstlisting}
is_disjoint(OSetA, {Key, _, Left, Right}) ->
    IsElem = is_element(Key, OSetA),
    if
        IsElem -> 
            false;
        true -> 
            is_disjoint(OSetA, Left) 
            and 
            is_disjoint(OSetA, Right)
	end.
			\end{lstlisting}
			Проверяется принадлежность корня OSetB множеству OSetA, и если корень
			принадлежит OSetA, то множества не являются пересекающимися. Иначе
			проверяется непересекаемость левого и правого поддерева множеству OSetA.
		
		
	\subsection{Перевод в список и обратно, свертка и фильтрация}
		\subsubsection{Перевод упорядоченного множества в список}
			\begin{lstlisting}
to_list({nil, black, nil, nil}) ->
    [];
			\end{lstlisting}
			Пустое множество переводится в пустой список.
			\begin{lstlisting}
to_list({Key, _, Left, Right}) ->
    to_list(Left) ++ [Key] ++ to_list(Right).
			\end{lstlisting}
			Для сохранения упорядоченности в список переводится левое поддерево, потом 
			добавляется корневое значение, а затем в список переводится правое поддерево.
			
		\subsubsection{Перевод списка в упорядоченное множество}
			\begin{lstlisting}
from_list(List) ->
    lists:foldl(fun(Elem, OSet) -> 
                    add_element(Elem, OSet) 
                end, 
                new(), 
                List).
			\end{lstlisting}			
			Перевод списка в упорядоченное множество реализуется с помощью стандартной 
			функции свертки списка и функции добавления элемета в множество. К каждому 
			элементу списка List, применяется функция fun(Elem, OSet) где Elem - элемент
			List, а в качестве OSet изначально берется пустое множество.
			
		\subsubsection{Свертка}
			Свертка fold(Fun, Acc, OSet) применяет к каждому элементу упорядоченного
			множества OSet функцию Fun(Elem, Acc) и возвращает итоговое значение Acc.
			\begin{lstlisting}
fold(_, Acc, {nil, black, nil, nil}) ->
    Acc;	
			\end{lstlisting}
			Если свертка применяется к пустому множеству, то просто возвращается Acc.
			\begin{lstlisting}
fold(Fun, Acc, {Key, _, Left, Right}) ->
    Fun(Fun(Key, fold(Fun, Acc, Left)), fold(Fun, Acc, Right)).
			\end{lstlisting}
			Если же свертка применяется к не пустому множеству, то Fun применяется к левому, 
			а затем и к правому поддереву.
		
		\subsubsection{Фильтрация}
			Фильтрация filter(Pred, OSet) применяет к каждому элементу OSet предикат Pred, и 
			возвращает упорядоченное множество элементов из OSet удовлетворяющих Pred.
			\begin{lstlisting}
filter(Pred, OSet) ->
    OSetList = to_list(OSet),
    FilteredList = lists:filter(Pred, OSetList),
    from_list(FilteredList).	
			\end{lstlisting}
			Упорядоченное множество переводится в список, список фильтруется с помощью стандартной 
			функции, а затем результат переводится из списка обратно в упорядоченное множество.
			
			
	\subsection{Объединение, пересечение, разность}
		Реализации операций объединения, пересечения и разности отличаются друг от друга, для 
		достижения лучшей скорости.
		
		\subsubsection{Объединение}
			Операция объединения реализована рекурсивно. 
			\begin{lstlisting}			
union(OSetA, {nil, black, nil, nil}) ->
    OSetA;
			\end{lstlisting}
			Объединением упорядоченного множества OSetA с пустым, будет упорядоченное множество OSetA.
			\begin{lstlisting}
union(OSetA, {Key, _, Left, Right}) ->
    union(union(add_element(Key, OSetA), Left), Right).
			\end{lstlisting}
			Для объединения упорядоченных множеств OSetA и OSetB, во множество OSetA добавляется корневой 
			элемент OSetB, а после применяется операция объединения OSetA к левому и правому поддереву OSetB.  
		
			Для объединения более чем двух упорядоченных множеств используется функция объединения от списка
			упорядоченных множеств.
			\begin{lstlisting}
union([OSet1, OSet2 | []]) ->
    union(OSet1, OSet2);
			\end{lstlisting}
			Если в списке всего два упорядоченных множества, то использовать операцию объединения от двух 
			упорядоченных множеств.
			\begin{lstlisting}
union([OSet1, OSet2 | OSetsListTail]) ->
    OSetUnion = union(OSet1, OSet2),
    union([OSetUnion | OSetsListTail]).
			\end{lstlisting}
			В противном случае, заменить в исходном списке два первых упорядоченных множества
			их объединением и найти объединение нового списка.
				
		\subsubsection{Пересечение}
			Операция пересечения реализована перебором одного из упорядоченных множеств.
			\begin{lstlisting}
intersection(OSetA, OSetB) ->
    intersection(OSetA, OSetB, {nil, black, nil, nil}).
			\end{lstlisting}
			При первом вызове операции пересечения для упорядоченных множеств OSetA и OSetB
			вызывается функция пересечения с пустым аккумулятором.
			\begin{lstlisting}	
intersection({nil, black, nil, nil}, _, Acc) ->
    Acc;
			\end{lstlisting}
			При пересечении любого упорядоченного множества с пустым множеством необходимо вернуть аккумулятор.
			\begin{lstlisting}	
intersection(OSetA, OSetB, Acc) ->
    OSetALeft = min(OSetA),
    OSetANew = del_element(OSetALeft, OSetA),
    IsElem = is_element(OSetALeft, OSetB),
    if 
        IsElem =:= true -> 
            AccNew = add_element(OSetALeft, Acc),
            intersection(OSetANew, OSetB, AccNew);
        IsElem =:= false -> 
            intersection(OSetANew, OSetB, Acc)
    end.
			\end{lstlisting}
			В противном случае удаляем из упорядоченного множества OSetA минимальный элемент, и если он 
			принадлежит еще и множеству OSetB, то добавляем его в аккумулятор, иначе находим пересечение 
			нового упорядоченного множества OSetA и неизмененного OSetB.
			
			Функция пересечения более чем двух упорядоченных множеств реализуется аналогично с объединением:
			\begin{lstlisting}
intersection([OSet1, OSet2 | []]) ->
    intersection(OSet1, OSet2);

intersection([OSet1, OSet2 | OSetsListTail]) ->
    OSetIntersection = intersection(OSet1, OSet2),
    intersection([OSetIntersection | OSetsListTail]).
			\end{lstlisting}
			
		\subsubsection{Разность}
			Операция разности двух упорядоченных множеств, как и операция пересечения, реализована 
			перебором одного из упорядоченных множеств.
			\begin{lstlisting}
subtract(OSetA, {nil, black, nil, nil}) ->
    OSetA;
			\end{lstlisting}
			Вычитание из упорядоченного множества OSetA пустого множества даст упорядоченное множество OSetA.
			\begin{lstlisting}
subtract(OSetA, OSetB) ->
    OSetBLeft = min(OSetB),
    OSetBNew = del_element(OSetBLeft, OSetB),
    IsElem = is_element(OSetBLeft, OSetA),
    if 
        IsElem =:= true -> 
            OSetANew = del_element(OSetBLeft, OSetA),
            subtract(OSetANew, OSetBNew);
        IsElem =:= false -> 
            subtract(OSetA, OSetBNew)
    end.	 	
			\end{lstlisting}
			Если же из упорядоченного множества OSetA вычитаем непустое упорядоченное множество OSetB,
			то удаляем из упорядоченного множества OSetB минимальный элемент, и если он 
			принадлежит еще и множеству OSetA, то удаляем его из множества OSetA и вычитаем из нового
			упорядоченного множества OSetA новое упорядоченное множество OSetB, иначе вычитаем из неизмененного
			упорядоченного множества OSetA новое упорядоченное множество OSetB.
			
			
			
			
\section{Сравнение с модулями sets и ordsets}
	В работе произведено сравнение времени выполнения стандартных операций реализованной мной структуры, со 
	стандарными структурами языка Erlang. Реализация упорядоченного множества oset~\cite{osetR} сравнивается со стандарным 
	упорядоченным множеством ordsets~\cite{ordsetsR} и	стандартным множеством sets~\cite{setsR}.
	
	В ходе сравнения данные считываются из текстового файла, заносятся в структуру и для каждой структуры проводятся
	замеры времени выполнения ее функций. Замер происходит дважды. В первый раз в текстовом файле находится 100 000 чисел 
	от 0 до 2 147 483 647 и 99 997 уникальных значений, а во второй от 0 до 10 000 и 10 000 уникальных значений. Время 
	указано в секундах.
	
	Ниже приведены таблицы замеров времени выполнения функций модулей ordsets, oset и sets.
	
	\begin{table}
	\centering
	\caption{Таблица времени выполнения с 99997 элементами в структуре}
	\begin{tabular} {|r|c|c|c|}
	\hline
 				& ordsets 	& oset		& sets \\
 	\hline
add\_element	& 1,93E-03	& 4,19E-05	& 4,65E-05 \\
del\_element	& 2,50E-03	& 4,80E-05	& 4,64E-05 \\
is\_element		& 4,63E-03	& 1,85E-06	& 4,51E-07 \\
to\_list		& 6,00E-08	& 2,44E-02	& 1,21E-02 \\
from\_list		& 7,39E-03	& 5,32E-01	& 5,91E-01 \\
is\_set			& 4,80E-03	& 1,08E-02	& 8,00E-08 \\
union			& 2,10E-02	& 4,91E-01	& 1,53E+00 \\
intesection		& 1,59E-02	& 7,63E-01	& 5,70E-02 \\
subtract		& 1,86E-02	& 7,66E-01	& 6,13E-02 \\
is\_subset		& 2,10E-07	& 1,94E-06	& 9,69E-03 \\
is\_disjoint	& 2,59E-04	& 1,88E-01	& 1,55E-02 \\
fold			& 1,36E-02	& 3,19E-02	& 1,83E-02 \\
filter			& 1,75E-02	& 2,98E-01	& 2,46E-02 \\
	\hline
	\end{tabular}
	\end{table}

	\begin{table}
	\centering
	\caption{Таблица времени выполнения с 10000 элементами в структуре}
	\begin{tabular} {|r|c|c|c|}
	\hline
 				& ordsets 	& oset		& sets \\
	\hline
add\_element	& 2,65E-04	& 3,70E-05	& 3,69E-05 \\
del\_element	& 6,03E-05	& 3,72E-05	& 3,76E-05 \\
is\_element		& 3,60E-04	& 1,36E-06	& 4,44E-07 \\
to\_list		& 7,00E-08	& 2,08E-03	& 9,33E-04 \\
from\_list		& 6,13E-04	& 3,19E-02	& 1,79E-02 \\
is\_set			& 3,31E-04	& 1,18E-03	& 7,00E-08 \\
union			& 6,01E-04	& 2,43E-02	& 1,07E-02 \\
intesection		& 6,59E-04	& 8,38E-02	& 4,22E-03 \\
subtract		& 3,70E-04	& 8,53E-02	& 4,64E-03 \\
is\_subset		& 3,61E-05	& 8,64E-03	& 3,11E-03 \\
is\_disjoint	& 9,00E-08	& 8,40E-07	& 8,81E-04 \\
fold			& 7,58E-04	& 2,23E-03	& 9,14E-04 \\
filter			& 1,01E-03	& 1,78E-02	& 1,70E-03 \\
	\hline
	\end{tabular}
	\end{table}
	
	\subsection{Вставка и удаление}
		В приведенных ниже временных показателях указано среднее время считывания 100 000 чисел из файла и занесения 
		их в структуру.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/add_element.png}
				\caption{Замер времени выполнения операции вставки}
		\end{figure}
		
		Аналогично и для операции удаления - время считывания чисел из файла и удаление их из структуры. 
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/del_element.png}
				\caption{Замер времени выполнения операции удаления}
		\end{figure}
		
		Как видно из рисунков 16 и 17, время выполнения операций вставки и удаления из модуля oset, сопоставимо 
		с временем выполнения операций в модуле sets, и существенно меньше времени выполнения этих операций
		в модуле ordsets. Это связано с тем, что упорядоченное множество в модуле ordsets реализовано 
		списком Erlang, а операции вставки и удаления линейны. 	
		
	\subsection{Логические функции}
		Логические функции, такие как is\_element, is\_subset и is\_disjoint запускаются по 100 раз
		каждая и в результат идет среднее время выполнения.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/is_element.png}
				\caption{Замер времени выполнения проверки на принадлежность элемента множеству}
		\end{figure}
		Благодаря тому, что модуль oset реализует упорядоченное множество на основе красно-черного дерева, операция
		проверки на принадлежность элемента множеству работает примерно за то же время, что и у модуля sets, и на 
		несколько порядков быстрее, чем у модуля ordsets, так как в нем эта операция реализована перебором всех элементов
		списка.  
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/is_subset.png}
				\caption{Замер времени выполнения проверки на то, является ли одно множество подмножеством другого}
		\end{figure}
		При большом объеме данных множества реализация проверки в модуле sets заметно уступает по времени 
		выполнения модулям ordsets и sets. Это связано с тем, что в модуле sets проверка реализована 
		последовательным перебором элементов одного множества и проверкой на его принадлежность другому. При малом 
		объеме данных реализация в модуле ordsets работает быстрее, из-за реализации струтуры данных с помощью 
		списка Erlang.  
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/is_disjoint.png}
				\caption{Замер времени выполнения проверки на непересекаемость двух упорядоченных множеств}
		\end{figure}
		Реализация данной проверки в модуле sets при малом количестве данных работает медленнее, как и в случае 
		с проверкой на то, является ли одно множество подмножеством другого, из-за последовательного перебора 
		элементов одного множества. При большом объеме данных рекурсивная реализация oset, уступает реализациям из 
		модулей ordsets и sets.
				
	
	\subsection{Перевод в список и обратно, свертка и фильтрация}
		При замере времени, как и с логическими функциями, каждая функция запускается по 100 раз, а в результат идет 
		среднее время выполнения.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/to_list.png}
				\caption{Замер времени выполнения перевода множества в список}
		\end{figure}
		Самой быстрой операцией перевода множества в список является реализация из модуля ordsets, так как 
		само множество реализовано с помощью списка. Реализация модуля sets использует операцию свертки и 
		поэлементно заполняет список. Реализация модуля oset рекурсивно добаляет в список значение корня,
		и добавляет к нему в начало список из левого поддерева, а в конец - из правого.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/from_list.png}
				\caption{Замер времени выполнения перевода списка в множество}
		\end{figure}
		На большом объеме множества реализации из модулей oset и sets работают приблизительно одинакого.
		Реализация модуля ordsets работает быстрее, так как она просто сортирует список.
		На малом объеме данных реализация модуля oset уступает реализации модeля sets.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/fold.png}
				\caption{Замер времени выполнения свертки}
		\end{figure}
		Свертка проверялась на функции сложения. Результатом ее выполнения являлась сумма элементов множества.
		Erlang умеет работать с большими числами, поэтому ошибок при вычислении свертки не происходило.
		Показатели времени выполнения операции свертки не сильно отличаются друг от друга, несмотря на то, что
		свертка в модуле ordsets реализована стандартной операцией свертки над списком. 

		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/filter.png}
				\caption{Замер времени выполнения фильтрации}
		\end{figure}
		Фильтрация проверялась на предикате проверяющем четность числа. Результатом ее выполнения являлось множество
		четных элементов. Операция фильтрации множества в модуле oset по времени выполнения уступает реализациям 
		модулей sets и ordsets. Отставание по времени связано с тем, что реализация oset использует перевод множества в 
		список и стандартную реализацию операции фильтрации для списка.

	\subsection{Объединение, пересечение, разность}
		Операции объединения, пересечения и разности запускаются по 100 раз и в результат 
		идет среднее время выполнения.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/union.png}
				\caption{Замер времени выполнения объединеия двух множеств}
		\end{figure}
		На большом объеме данных реализация модуля sets уступает двум другим, потому что реализована с поможщью свертки.
		На малом объеме данных в модуле oset самая медленная реализация операции объединения двух множеств, так как
		реализована рекурсивно. Реализация модуля ordsets в обоих случаях работает быстрее. Это происходит из-за 
		реализации самого множества с помощью списка, и быстроты операций с ним.
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/intersection.png}
				\caption{Замер времени выполнения пересечения двух множеств}
		\end{figure}
		
		\begin{figure}[H]
				\centering
				\includegraphics[width=\textwidth]{img/histograms/subtract.png}
				\caption{Замер времени выполнения разности двух множеств}
		\end{figure}
		Время выполнения операций пересечения двух упорядоченных множеств и их разности в модуле oset уступает времени
		выполнения этой	же операции в модулях sets и ordsets. Длительность выполнения связана с последовательным перебором
		всех элементов одного из множеств.
		
\Conc

	В рамках работы изучены принципы функционального программирования, а также реализовано упорядоченное
	множество на основе красно-черного дерева. Было произведено сравнение времени выполнения основных функций 
	модулей ordsets, oset и sets и проанализированна зависимость времени выполнения от реализации структуры данных.

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
